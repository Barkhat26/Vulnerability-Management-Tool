import editdistance
from matching.search_terms_generator import generate_product_search_terms
from matching.search_terms_generator import remove_version_from_search_terms
from matching.search_terms_generator import generate_vendor_filters
from matching.software_formatter import FormattedSoftware
# from database import Database
from matching import cpe_sorter
from wfn.wfn_converter import WFNConverter
from models import CPE
import progressbar
import logging
import json
from database import Database

# progressbar.streams.wrap_stderr()
logging.basicConfig(level=logging.INFO, format="%(message)s")

class CPEMatcher:
    def __init__(self):
        self.db = Database()
        self.wfn_creator = WFNConverter()

    def search_cpes_for_software(self, software):
        formatted_sw = FormattedSoftware(software)
        product_search_terms = generate_product_search_terms(formatted_sw.product, formatted_sw.vendor)
        version = formatted_sw.get_version(product_search_terms)
        product_search_terms = remove_version_from_search_terms(product_search_terms, version)

        candidates = self.search_cpe_candidates_by_product(product_search_terms)
        filtered_candidates = filter_cpe_candidates_by_vendor(candidates, formatted_sw.vendor, product_search_terms)
        ordered_candidates = sort_cpe_candidates_by_version(filtered_candidates, version, product_search_terms)
        return ordered_candidates

    def search_cpe_candidates_by_product(self, product_search_terms):
        candidates = init_candidates_lists(product_search_terms)
        logging.info('Obtaining CPEs from a database...')
        cpes_generator = Database().get_cpes()
        cpes_count = Database().get_cpe_count()
        logging.info('Done. Total number of CPEs: %d' % cpes_count)
        logging.info('Stage 1/3: search cpe candidates by product')

        with progressbar.ProgressBar(max_value=cpes_count+1) as bar:
            progressbar_idx = 1
            for cpes in cpes_generator:
                for cpe in cpes:
                    wfn_product = cpe['product']
                    for search_term in product_search_terms:
                        if are_strings_similar(wfn_product, search_term) and (cpe not in candidates.get(search_term)):
                            candidates.get(search_term).append(cpe)
                            break
                    progressbar_idx += 1
                    bar.update(progressbar_idx)
        return candidates

    def get_cpe_dictionary(self):
        db = Database()
        return db.get_cpes()


def init_candidates_lists(product_search_terms):
    candidate_lists = {}
    for search_term in product_search_terms:
        candidate_lists[search_term] = []
    return candidate_lists


def filter_cpe_candidates_by_vendor(candidates, vendor, product_search_terms):
    logging.info('Stage 2/3: filter cpe candidates by vendor')
    with progressbar.ProgressBar(max_value=len(product_search_terms)) as bar:
        for idx, search_term in enumerate(product_search_terms):
            candidates[search_term] = filter_by_vendor(candidates[search_term], vendor)
            bar.update(idx)
    # progressbar.streams.flush()
    return candidates


def filter_by_vendor(cpes, vendor):
    filtered_cpe_matches = []
    for cpe in cpes:
        for filter_ in generate_vendor_filters(vendor):
            wfn_vendor = cpe['vendor']
            if are_strings_similar(filter_, wfn_vendor):
                filtered_cpe_matches.append(cpe)
    return filtered_cpe_matches


def sort_cpe_candidates_by_version(candidates, version, product_search_terms):
    all_sorted_candidates = []
    logging.info('Stage 3/3: sorting cpe candidates by version')
    with progressbar.ProgressBar(max_value=len(product_search_terms)) as bar:
        for idx, search_term in enumerate(product_search_terms):
            if search_term == 'jdk' or search_term == 'jre':
                version = '1.' + version
            sorted_candidates = cpe_sorter.sort_cpes_by_version(candidates.get(search_term), version)
            all_sorted_candidates.extend(sorted_candidates)
            bar.update(idx)
    # progressbar.streams.flush()
    return all_sorted_candidates


def are_strings_similar(string_a, string_b):
    return editdistance.eval(string_a, string_b) <= 2  # Changed from 2
